+-----------------------+
|         CS 124        |
| PROJECT 2: BOOTLOADER |
|    DESIGN DOCUMENT    |
+-----------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Hamik Mukelyan 	  <hamik@caltech.edu>
Sushant Sundaresh <sushant.sundaresh@gmail.com>
David Luo 	      <dluo@caltech.edu>

>> Specify how many late tokens you are using on this assignment: 0

>> What is the Git repository and commit hash for your submission?
   (You only need to include the commit-hash in the file you submit
   on Moodle.)

   Repository URL:  login.cms.caltech.edu:/cs/courses/cs124/teams/Curiosity
   commit TODO

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course instructors.

http://www.independent-software.com/writing-your-own-toy-operating-system/
wiki.osdev.org
wikipedia.comx

			     PC BOOTER
			     =========

---- LOGISTICS ----

These questions will help us to keep track of the difficulty level of
assignments, as well as keeping track of which team members worked on
which parts.

>> L1: How many hours did each team member spend on this assignment?
   Make sure that each member's total time is listed.
   
   Sushant: 23
   David: 20
   Hamik: 25

>> L2: What did each team member focus on for this assignment?  Keep
   descriptions to 25-30 words or less.

   Hamik: flappy bird game, keyboard, video
   Sushant: bootloader assembly code, interrupts, handlers
   Dave: timer, keyboard, debugging WIZARD

Note that this design document is a bit long.  Most of the questions can be
answered pretty briefly.  Don't feel a need to write a long answer if it is
not required by the question.

			     GAME / DEMO
			     ===========

---- ALGORITHMS ----

>> A1: In 25-30 words or less, what does your PC booter do?

It gets the program binary from the emulated floppy into a specific location,
sets up the GDT, and transitions segment registers into 32-bit protected mode,
disabling interrupts.

>> A2: In 25-30 words or less, how does the user interact with the program?
>> What are the controls?  What should the user try to do?

The controls and gameplay are briefly explained on our game's splash screen.
Press 'f' the keep Flappy The Bird flying and 'q' to quit. If Flappy crashes
you can play again by pressing 'f'.

---- DATA STRUCTURES ----

>> A3: Describe any global state that your program manages in order to
>> perform its operations.  Don't focus on state managed within interrupt
>> handlers; we will look at that later.  Rather, focus on state that is
>> part of the game implementation itself.

Our program is pretty simple... it just keeps track of:
 - the user's score
 - best score 
 - whether the user requested a restart at the death screen
 - our pseudorandom number generator's seed (which is set to the number of
   timer interrupts at the time the user presses 'f' for the first time)
 - and the current frame number

---- SYNCHRONIZATION ----

>> A4: From the perspective of the entire program, briefly describe how
>> the various interrupts are handled and processed within your program.
>> For example, when a timer interrupt occurs, what is the general sequence
>> of operations or updates that is performed within your program?
>> Similarly, when a keyboard interrupt occurs, what does your program do
>> in response?

A timer interrupt simply updates a global counter. The main loop accesses
this counter through sleep-like functions to wait with less needless looping.

The keyboard interrupts simply enqueue the raw input from the keyboard 
controller into a circular buffer. 

>> A5: Would you say your program relies on polling or busy-waiting anywhere
>> to accomplish its tasks?  If so, what tasks?

We only do this in getch() with flag=1 to block until we receive user input.
We could have done this with a halt.

---- RATIONALE ----

>> A6: Why did you choose the project you did?

It has a simple keyboard interface, everyone knows the game, and it's super
addictive.

>> A7: Did your choice of project affect any of the specific implementation
>> details of the various subsystems that you needed to use?  (For example,
>> if you implemented a scrolling game, did you implement specialized high-
>> performance video code to scroll the screen?)

Our video code is naive: it just writes a given string to a particular
x, y coordinate with a given background and foreground color. It's invoked like
mvprintfcol(x, y, BKGCOL, FRGCOL, "Hi, I am a string.").

>> A8: Did you run into any technical or resource limitations in the
>> implementation of your program?  (For example, bootloader didn't fit,
>> or a really useful standard library wasn't available, or you couldn't
>> achieve the desired performance level, etc.)  If so, what steps did you
>> take to try to overcome those limitations?

Flappy Bird isn't interesting unless pipe opening heights are random between
games and of course between pipes. rand() is implemented in the stdlib.h, so
we couldn't use it in our program. Instead we used a hackish approach where
our random number generator takes a prime number, multiplies a seed, mods by a
prime number, sets the seed to the new number, then returns the new seed. 
The seed starts out as the number of timer interrupts between boot and the 
first key press.

			     BOOT SECTOR
			     ===========

---- DATA STRUCTURES ----

>> B1: How did you decide to store the Disk Address Packet?  Does the
>> memory occupied by the DAP get reclaimed after it is used?  If not,
>> why not?

I stored it on the stack. The stack pointer is not changed after we switch
to 32-bit protected mode, and our boot function never cleans up its own stack.
There was no reason to; we have >48 kB stack from 0xf000 to 0x7e00; more
if we were willing to overwrite out bootloader (no issue) and we
never use more than a fraction of it for flappy.

>> B2: Does your bootloader pass any information to the main program?
>> (If not, just say no.)  If so, what information is passed, and how
>> is it passed?

No. The GDT is a static data structure and the higher level code takes it
for granted.

---- ALGORITHMS ----

>> B3: Briefly describe how your bootloader brings your program into
>> memory.  Does it perform one large load, or multiple smaller loads?

One large load of 64kB.

>> B4: Did you add any BIOS calls to your bootloader to prepare for your
>> main program?  (i.e. things that aren't available in protected mode)

Other than the int 0x13 and int 0x10 that you spec'd out for us, no.

			  VIDEO SUBSYSTEM
			  ===============

---- DATA STRUCTURES ----

>> C1: What video display mode does your program use?  Is it a text mode
>> or a graphical mode?  Where does the video buffer start?  How is data
>> represented in this mode?  (Please be brief; we don't need complete
>> documentation on the video system.)

Text mode. The video buffer starts at 0xB8000 and ends at 0xB8F9F. The second,
undisplayed page starts at 0xB8FA0 and ends 25 * 80 * 2 bytes later. Our
display function mvprintfcol takes the coordinate at which the given string
should be printed, maps it to memory by adding the number of preceding 
characters * 2, then prints the chars in the given string in order.

>> C2: Does your video code maintain any variables or data structures to
>> facilitate video output?  Briefly describe these values and their
>> purposes here.

Video buffer is 80x25x2chars long. The actual buffer itself, allocated by
BIOS or whatever is 8x that space. So we write to page 2 of the video buffer,
and when we call refresh_screen() it writes it directly to page 1. 

---- ALGORITHMS ----

>> C3: What abstraction does your video code present to your main program?
>> Briefly describe the higher-level operations you decided to implement.

We implemented set_bkg, clear_screen, mvprintfcol, and refresh_screen. They
will usually be used in that order. set_bkg sets the default background color
that will be used when clear_screen is called, which walks through the entire 
second page of video memory and sets all the background colors to the default.
mvprintfcol stands for "move, printf, color" and does what it sounds like:
given an x, y coordinate, a background color, a foreground color, and a string
it prints the string to the given coordinates. refresh_screen then copies all
the data from the second page into the first page (the user has to call
clear_screen to get rid of the contents of the second screen).

---- RATIONALE ----

>> C4: Did you take any specific steps to improve the appearance of your
>> program's display output?  For example, using Extended ASCII Codes, or
>> choosing specific colors to represent different things?

We support different colors through the mvprintfcol function but found a 
WHITE on BLACK display most appealing.

			  TIMER SUBSYSTEM
			  ===============

---- DATA STRUCTURES ----

>> D1: What state does your timer subsystem manage?  Describe the variables
>> or data structures that it maintains, and how they are used.

It maintains one global integer counter used to count milliseconds (we 
interrupt at 1kHz) for setting variable frame rate.

---- ALGORITHMS ----

>> D2: What abstraction does your timer code present to your main program?
>> Briefly describe the higher-level operations you decided to implement.

It presents a currtime() accessor to the counter, and mysleep(int ms) 
which lets you sleep for a specified integer millesecond count.

>> D3: Did you change the timer frequency from 100Hz?  If so, what did you
>> change it to, and why?

Yes, to 1kHz, so we could make frame rate variable without having to keep
recalculate timer configuration. It was for convenience, and at 1 MHz we
were in no danger of missing other interrupts. 

---- SYNCHRONIZATION ----

>> D4: Given how your program handles timer events, is there any potential
>> for timer interrupts to generate race conditions in updating your
>> program's global state?  If so, what steps did you take to ensure that
>> such situations cannot occur?

We read the counter value, but we rarely care what it actually is with
ms precision. There is a possibility that timers cause momentary 
keypress interrupt misses, due to priority, but the keyboard has a buffer 
and the user has a limit to how quickly they can press keys. We can clear 
the keyboard buffer far faster than the user can fill it up.

			KEYBOARD SUBSYSTEM
			==================

---- DATA STRUCTURES ----

>> E1: What state does your keyboard subsystem manage?  Describe the variables
>> or data structures that it maintains, and how they are used.

It manages no state. We do not initialize the keypad; we keep the Set 1 that
the BIOS initialized for us. We maintain a circular queue with an interrupt
safe dequeue accessor and an interrupt-only enqueue accessor to keep
any scan codes the keypad chooses to send over, without any kind of parsing.

>> E2: How do your data structures handle keys with multi-byte scan-codes?

We don't - we only needed two keys for our game (f,q) and so we ignore
anything else - even errors. The user shouldn't be using Flappy Bird to
figure out their keypad is broken.

---- ALGORITHMS ----

>> E3: What abstraction does your keyboard code present to your main program?
>> Briefly describe the higher-level operations you decided to implement.

It presents a dequeue that always returns quickly, even if the queue is empty.

It presents getch(int blockFlag) wrapper for dequeue which can be set up to 
keep trying to dequeue until it finds a valid scan-code (f,q) or, alternatively,
to return 0 on reaching the end of the queue without finding an appropriate 
code. This allows us to ignore the details of scan codes in the main program.

>> E4: Does your keyboard subsystem expose scan-codes directly to your main
>> program, or does it preprocess them and expose other information to your
>> main program?  If scan-code data is preprocessed, briefly describe what
>> information is actually exposed, and how it is derived from scan-codes.

It preprocesses them into "f" or "q" through getch(), using set-1 scan codes
which are the default with QEMU to map 'f' and 'q' key press (not release)
into 'f' and' q' characters.

---- SYNCHRONIZATION ----

>> E5: Given how your keyboard interrupt handler operates, is there any
>> potential for race conditions in updating the keyboard subsystem's
>> internal state?  If so, what steps did you take to ensure that such
>> situations cannot occur?

No. We made dequeue interrupt safe by wrapping in cli/sti. 
Enqueue is only called by the interrupt handler and we don't enable
nested interrupts so there's no issue there.

We also know we can process the keyboard's internal buffer way faster 
than the user can generate keypad events.

>> E6: Given how your program handles keyboard events, is there any
>> potential for keyboard interrupts to generate race conditions in updating
>> your program's global state?  If so, what steps did you take to ensure
>> that such situations cannot occur?

No. 

---- RATIONALE ----

>> E7: Why did you choose the design and data representation that your
>> keyboard subsystem uses?  How is it suited to your program's overall
>> operation?

We chose to only accept presses of 'f' to move flappy up and 'q' to quit 
the game. These key presses are only one byte scan codes, so we don't have 
to worry about two byte scan codes; i.e. we discard any scan codes that 
don't correspond to 'f' or 'q'. 

We used a circular queue as a fixed array to store the scan codes. 
This is faster than using a linked list implementation of a circular 
queue because there is better cache utilization with a linear array than
with a linked node data structure, but of course the efficiency gains for
us are negligible. The array implementation of a circular queue is
simpler than a linked list one. Circular array-based queues and linked
list-based queues both have O(1) insertion and removal, but linked list
versions have the benefit of never needing an expensive resize operation.
We didn't need that benefit though because it's reasonable to expect there
will never be many unprocessed key presses in the key buffer.


			  SURVEY QUESTIONS
			  ================

Answering these questions is optional, but it will help us improve the
course in future years.  Feel free to tell us anything you want - these
questions are just to spur your thoughts.  Also, feel free to be completely
honest if there are issues with the assignment or the course - you won't be
penalized.  We can't fix things until we know about them.  :-)

>> In your opinion, was this assignment, or any of the parts of it, too
>> easy or too hard?  Did it take too long or too little time?

It took us forever to do the bootloader, but it was very easy, in retrospect,
because you did everything for us. If you hadn't given us the meaty skeleton
I suspect we'd have cried ourselves to sleep every night, which says something.
We'd probably have the structure of the code sink in more if there were many 
TAs and we had to write it from scratch, but this way we saw the birds eye view
and had the super cool experience of making a game without an OS. 

It took us way longer than most, I think, and I don't know why. It wasn't 
HARD, it was just.. a debugging experience. Better now than later!

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

The bootloader process was very worthwhile. We've gotta get comfortable
with assembly and hardware instead of seeing these as abstractions we can
usually avoid with C. This was the first time I've seen things I 
"needed" to write in assembly.

Working on the timer gave better perspective on the flow between how the 
clock can be used for periodic interrupts, and how interrupts from the 
keyboard can be handled.

>> Were there any parts of the assignment that you felt were unnecessarily
>> tedious or pointless?

No. It was all worthwhile; there's no other way to force it to sink in 
and wrapping it in a fun game was icing on the cake.

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

The 3 DPL bits are NOT the only bits to set in that IDT byte.

Set architecture to i386 or just keep the default architecture, instead of
i8086, when you debug 32 bit protected code, or addresses will be funky 
in your compiled assembly code.

>> Do you have any suggestions for the instructor and/or TAs to more
>> effectively assist students, either for future quarters or the remaining
>> projects?

I loved/hated Glen's 119 series because he gave zero code. We had to design
from scratch. Things took WAY longer, but the design experience is really
important too. Especially down there; we're all comfortable with design
in high level languages, but throw assembly and the discomfort with what
we're supposed to be doing in the first place.. it's a toss up. If you were
going to do that, we'd need dedicated TA support.

>> Any other comments?

No.
