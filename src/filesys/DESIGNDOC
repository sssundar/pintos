                     +-------------------------+
                     |          CS 124         |
                     | PROJECT 6: FILE SYSTEMS |
                     |     DESIGN DOCUMENT     |
                     +-------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Hamik Mukelyan <hamik@caltech.edu>
Sushant Sundaresh <sushant.sundaresh@gmail.com>
Dave Luo <dluo@caltech.edu>

>> Specify how many late tokens you are using on this assignment: 0

>> What is the Git repository and commit hash for your submission?

   Repository URL: login.cms.caltech.edu:/cs/courses/cs124/teams/Curiosity
   commit TODO

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

TODO

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course instructors.

TODO

             INDEXED AND EXTENSIBLE FILES
             ============================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

TODO

>> A2: What is the maximum size of a file supported by your inode
>> structure?  Show your work.

Well, consider a single file that takes up the entire disk (no directory), 
as an edge case. 

The inode metadata in the first sector (2^9 bytes) takes up 12 bytes.
That leaves 500 bytes in the sector, or 125 block_sector_t values
on a 4-byte integer/address architecture like ours.

In this set, we can have n_d, n_is and n_id as the number of direct,
indirect (singly) and indirect (doubly) sector references. Direct references
are the numbers of sectors of data, indirect references are the numbers of
sectors which contain numbers of sectors of data as their data, and so on.

This makes it really easy to know which direct, singly indirect, or doubly 
indirect sector reference to look at, if you know the position you want in
your file. 

It's worth noting that:
  Indirect references point to sectors without headers. They can
  hold 128 (2^7) metadata entries or direct sector numbers.

  and

  The file would be arranged linearly in this structure, and we'd fill out
  the sector references compactly so jumping from offset -> reference in the
  index structure remains simple.

This works out to;

Metadata: 
  one sector, an inode_disk
  n_is sectors as singly indirect references (n_is sectors worth of bytes)
  n_id sectors as doubly indirect references
  n_id * 128 sectors as singly indirect references

Data
  n_d sectors 
  n_is * 128 sectors
  n_id * 128 * 128 sectors

with the constraint that n_d + n_is + n_id = 125.

This, collectively, takes up:
  [1 + n_is + n_id*129 + n_d + n_is*128 + n_id*128*128 ] * 512 bytes

  which is
  [1 + n_d + (2^7 + 1)* n_is + (1 + 2^7 + 2^14) * n_id ] * 2^9 bytes

  Keep in mind that 8 Mb = 8 * 2^20 bytes. 

  If there are integers n_d, n_is, and n_id >= 0 such that
    n_d + n_is + n_id = 125.
  and
    [1 + n_d + (2^7 + 1)* n_is + (1 + 2^7 + 2^14) * n_id ] * 2^9 >= 8 * 2^20

  Then we can have a single file that can cover the entire file system. 

Now, the question is, how do our choices of these integers affect efficiency
of traversal for different kinds of files, and metadata-vs-data usage?

If we make n_d small, we're almost always fetching multiple sectors from disk
for our traversals, so small files suffer losses unnecessarily. If we make n_d
large, then file sizes might be capped, unless we allow further indirection.

Right now we have three constraints: 
  - 8 Mb-file capable file system requirement (including metadata)
  - three levels of indirection 
  - size of a block sector

These have yielded two linear equations in three unknowns.

We need a final constraint, one of efficiency, and that will yield a
solution we can run with. 

Let's arbitrarily force at least the first 32kB of a file to be directly or 
singly accessible, just so most text files, directory structure, and small
program sectors are about three sector-reads away.

That means    (n_d + n_is * 2^7) * 2^9 bytes >= 2^15 bytes
or, we have three equations, and we're trying to find integer solutions.

n_d + n_is*2^7 >= 2^6
n_d + n_is + n_id = 125.
[1 + n_d + (2^7 + 1)* n_is + (1 + 2^7 + 2^14) * n_id ] * 2^9 >= 8 * 2^20

This clarifies things immensely. The added constraint is irrelevant,
we immediately see that: 2^9 * 2^14 = 2^23 = 8 * 2^20, so even a single
doubly indirect reference is enough to cover the filesystem.

This isn't a question of being able to reference that much space, it's a
question of how to do so quickly. 

Using n_id = 1 means n_id + n_is = 124. Say we split evenly. Then
n_d = 62 abd n_is = 64, so, after reading the base inode,
  one sector read away:   ~32kbytes
  two sector reads away:  ~4Mb
  three sector reads away: 8 Mb

That seems pretty freaking reasonable to me. 32kB is enough for small programs,
4Mb is enough for something like Pintos, I bet, and 8 Mb is enough for 
normal sized data files like music or photos. 

Ok, so let's use n_d = 62, n_is = 62, and n_id = 1. That allows one file to
address n_d + n_is*2^7 + n_id*2^14 sectors of data, or 12,483,584 bytes, 
taking up a total of 1 + 62 + 1 + 128 sectors of metadata, or 93,304 bytes 
of metadata. That's 0.08% metadata for a 12.5Mb maximum file size!

I'm sure there are optimal solutions depending on use case. This seems good
enough for any file I'd use (other than say, a video), to be honest. I imagine
that in reality people have inode headers that say what the breakdown is,
varying by file size, to optimize for different ranges of sizes.

---- SYNCHRONIZATION ----

>> A3: Explain how your code avoids a race if two processes attempt to
>> extend a file at the same time.

TODO

>> A4: Suppose processes A and B both have file F open, both
>> positioned at end-of-file.  If A reads and B writes F at the same
>> time, A may read all, part, or none of what B writes.  However, A
>> may not read data other than what B writes, e.g. if B writes
>> nonzero data, A is not allowed to see all zeros.  Explain how your
>> code avoids this race.

TODO

>> A5: Explain how your synchronization design provides "fairness".
>> File access is "fair" if readers cannot indefinitely block writers
>> or vice versa.  That is, many processes reading from a file cannot
>> prevent forever another process from writing the file, and many
>> processes writing to a file cannot prevent another process forever
>> from reading the file.

TODO

---- RATIONALE ----

>> A6: Is your inode structure a multilevel index?  If so, why did you
>> choose this particular combination of direct, indirect, and doubly
>> indirect blocks?  If not, why did you choose an alternative inode
>> structure, and what advantages and disadvantages does your
>> structure have, compared to a multilevel index?

TODO

                SUBDIRECTORIES
                ==============

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

TODO

---- ALGORITHMS ----

>> B2: Describe your code for traversing a user-specified path.  How
>> do traversals of absolute and relative paths differ?

TODO

---- SYNCHRONIZATION ----

>> B4: How do you prevent races on directory entries?  For example,
>> only one of two simultaneous attempts to remove a single file
>> should succeed, as should only one of two simultaneous attempts to
>> create a file with the same name, and so on.

TODO

>> B5: Does your implementation allow a directory to be removed if it
>> is open by a process or if it is in use as a process's current
>> working directory?  If so, what happens to that process's future
>> file system operations?  If not, how do you prevent it?

TODO

---- RATIONALE ----

>> B6: Explain why you chose to represent the current directory of a
>> process the way you did.

TODO

                 BUFFER CACHE
                 ============

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

TODO

---- ALGORITHMS ----

>> C2: Describe how your cache replacement algorithm chooses a cache
>> block to evict.

TODO

>> C3: Describe your implementation of write-behind.

TODO

>> C4: Describe your implementation of read-ahead.

TODO

---- SYNCHRONIZATION ----

>> C5: When one process is actively reading or writing data in a
>> buffer cache block, how are other processes prevented from evicting
>> that block?

TODO

>> C6: During the eviction of a block from the cache, how are other
>> processes prevented from attempting to access the block?

TODO

---- RATIONALE ----

>> C7: Describe a file workload likely to benefit from buffer caching,
>> and workloads likely to benefit from read-ahead and write-behind.

TODO

               SURVEY QUESTIONS
               ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the feedback survey on the course
website.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

TODO

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

TODO

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

TODO

>> Do you have any suggestions for the TAs to more effectively assist
>> students in future quarters?

TODO

>> Any other comments?

TODO